{
  "1": {
    "testNumber": 1,
    "title": "includeSubdomains Attribute in HSTS Headers",
    "description": "How is the 'includeSubdomains' attribute interpreted in the browser? Does it correctly make the HSTS settings for the calling host itself and its subdomains? Does it also include neighbour hosts or the apex domain?",
    "detailedDescription": "### Introduction\nThe [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) HTTP header, often called HSTS, instructs the browser how SSL/TLS should be handled for this web site, e.g.:\n``` \nStrict-Transport-Security: max-age=31536000; includeSubDomains\n```\nThe above example tells the browser a number of things:\n1. This web site must only be called via HTTPS, never via HTTP.\n2. If an HTTP connection for this web site is requested, the browser automatically upgrades to HTTPS.\n3. This setting will be stored in the browaser for 31536000 seconds or 1 year.\n4. This setting is also applied to all subdomains of the current web site.\n\nThis header is an important defence against man-in-the-middle attacks where an attacker tries to intercept connections before the SSL encryption is active and change HTTPS links to HTTP (so-called [SSL stripping](https://moxie.org/software/sslstrip/) attacks).\n\n### Problem\nImagine the server the following ``Strict-Transport-Security`` header when the browser loads a page from ``https://www.canitrust.in``:\n```\nHTTP/1.1 200 OK\n[...]\nStrict-Transport-Security: max-age=31536000; includeSubDomains\n[...]\n```\nIn this example, the server sets an HSTS header for 1 year (31536000 seconds) for ``www.canitrust.in`` but also for subdomains like ``foo.www.canitrust.in``. It should, however, *not* make these settings for other hosts in the same domain like ``bar.canitrust.in`` or even the [apex domain](https://www.netlify.com/blog/2017/02/28/to-www-or-not-www/) itself (``canitrust.in``).\n\n### How does the browser react?\nWhen the browser receives such an HSTS header with the ``includeSubDomains`` attribute when loading a web site, it has the following options:\n\n1. Set the HSTS setting for this host and its subhosts. Other hosts on the same level or the apex domain do not get this setting. This is the correct implementation according to the specification.\n2. Set the HSTS setting for this host, its subhosts and also for hosts at the same level. The apex domain does not get this setting.\n3. Set the HSTS setting for this host, its subhosts and also for teh apex domain. Hosts at the same level do not get this setting.\n4. Set the HSTS setting for this host, its subhosts, for hosts at the same level and also for the apex domain.\n5. Ignore the ``includeSubDomains`` header and only set the HSTS settings for this host.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "1/17/2019",
    "tagNums": [
      4,
      8
    ],
    "path": "includeSubdomains-in-HSTS",
    "question": "How does the browser interpret the 'includeSubdomains' attribute?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "Correctly make the HSTS settings for the host itself and its subdomains"
      },
      {
        "ans_id": 2,
        "ans_desc": "Only make the HSTS settings for the host itself and ignore the 'includeSubdomains' attribute"
      },
      {
        "ans_id": 3,
        "ans_desc": "Make the HSTS settings for the host itself, its subhosts and its neighbour hosts"
      },
      {
        "ans_id": 4,
        "ans_desc": "Make the HSTS settings for the host itself and the apex domain"
      },
      {
        "ans_id": 5,
        "ans_desc": "Make the HSTS settings for the host itself, its subhosts and the apex domain"
      },
      {
        "ans_id": 0,
        "ans_desc": "HSTS is not supported"
      }
    ]
  },
  "2": {
    "testNumber": 2,
    "title": "HSTS Headers via plain http",
    "description": "Does the browser accept an HSTS header when set by a non-HTTPS web site? This should not be the case as it would allow for man-in-the-middle attacks.",
    "detailedDescription": "### Introduction\nThe [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) HTTP header, often called HSTS, instructs the browser how SSL/TLS should be handled for this web site, e.g.:\n``` \nStrict-Transport-Security: max-age=31536000\n```\nThe above example tells the browser a number of things:\n1. This web site must only be called via HTTPS, never via HTTP.\n2. If an HTTP connection for this web site is requested, the browser automatically upgrades to HTTPS.\n3. This setting will be stored in the browaser for 31536000 seconds or 1 year.\n\nThis header is an important defence against man-in-the-middle attacks where an attacker tries to intercept connections before the SSL encryption is active and change HTTPS links to HTTP (so-called [SSL stripping](https://moxie.org/software/sslstrip/) attacks).\n\n### Problem\nImagine the browser requests ``http://www.canitrust.in`` (note the ``http://`` part) and the server sends a ``Strict-Transport-Security`` header in the reponse:\n```\nHTTP/1.1 200 OK\n[...]\nStrict-Transport-Security: max-age=31536000\n[...]\n```\nIn this example, the server tried to set the ``Strict-Transport-Security`` header for a web site that was loaded via HTTP. This should not work as it would allow attackers to intercept the request and set different HSTS headers or turn them off completely.\n\n### How does the browser react?\nWhen the browser receives an HSTS header when loading a non-HTTPS web site, it has the following two options:\n\n1. Ignore the header and not store any HSTS setting from this request. This is the correct and secure implementation.\n2. Accept the header and store its HSTS setting. This is a vulnerable implementation.\n\nThis testcase tests which browser chooses which of these two options.",
    "date_created": "11/28/2019",
    "tagNums": [
      4
    ],
    "path": "hsts-via-plain-http",
    "question": "Is the HSTS header processed if received via plain http?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "No"
      },
      {
        "ans_id": 0,
        "ans_desc": "Yes"
      }
    ]
  },
  "3": {
    "testNumber": 3,
    "title": "Is the header processed if received via https with invalid certificate? Will the invalid certificate be accepted by the next connection?",
    "description": "Approach: Turn off proxy. Visit https://invalidcert.example.mgm  Check if browser chooses https next time. Example: Header ignored, header accepted and enforced upon next session, i.e. after closing tab and browser and accessing the site again.",
    "date_created": "1/17/2019",
    "tagNums": [
      4
    ],
    "path": "HSTS-with-invalid-certificates",
    "question": "",
    "possibleAnswers": [
      {
        "ans_id": 2,
        "ans_desc": "Processed via https with invalid certificate"
      },
      {
        "ans_id": 3,
        "ans_desc": "A plus certificate accepted by the next connection"
      },
      {
        "ans_id": 4,
        "ans_desc": "Header not processed"
      }
    ]
  },
  "6": {
    "testNumber": 6,
    "title": "Contradicting Cookie Headers",
    "description": "Which cookie prevails in case of contradicting cookie headers? The first or the second? Or does the browser even completely ignore the cookie?",
    "detailedDescription": "### Introduction\nCookies are key-value pairs which the server can set in the calling browser, like so:\n``` \nSet-Cookie: foo=bar; Max-Age=2592000; HttpOnly\n```\nIf a request is made to a server, the browser will automatically send all cookies stored for this [origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin). This is particularly usefull for [session management](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#cookies) where cookies will be used to store session identifiers (session IDs). This behaviour makes such session cookies highly security relevant.\n\n### Problem\nNow imagine that a server sends two ``Set-Cookie`` headers to the browser which contain two different values for the same cookie, e.g.:\n```\nHTTP/1.1 200 OK\n[...]\nSet-Cookie: foo=value1;\nSet-Cookie: foo=value2;\n[...]\n```\nThis can happen if two infrastructure components (e.g. application server and web server) both try to control the cookie and pick different values which leads to unpredictable behaviour.\n\n### How does the browser react?\nWhen receiving two contradicting values for the same cookie in separate ``Set-Cookie`` headers, the browser now  has three options:\n\n1. Accept the header which is listed first in the HTTP request and ignore the second.\n2. Accept the second header and ignore the first.\n3. Ignore the cookie altogether.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "1/17/2019",
    "tagNums": [
      2,
      7
    ],
    "path": "contradicting-cookie-headers",
    "question": "Which cookie wins?",
    "possibleAnswers": [
      {
        "ans_id": 2,
        "ans_desc": "The first"
      },
      {
        "ans_id": 3,
        "ans_desc": "The second"
      },
      {
        "ans_id": 0,
        "ans_desc": "Neither"
      }
    ]
  },
  "8": {
    "testNumber": 8,
    "title": "Foreign Domain Attribute in Cookie Declaration",
    "description": "What happens if a server sets a cookie that has a foreign domain set in the domain attribute? Is the cookie ignored by the browser?",
    "detailedDescription": "### Introduction\n[Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) are key-value pairs which the server can set in the calling browser, like so:\n``` \nSet-Cookie: foo=bar; Domain=example.com\n```\nIn the above example, the server sets the cookie ``foo`` with the value ``bar`` and sets the domain for which this cookie should be sent. If the domain attribute is set, it will be valid for all subdomains as well. If the domain attribute is not set, the browser will default to the current host, not including subdomains.\n\nIf a request is made to a server, the browser will automatically send all cookies stored for this [origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin) or stored for the domain if the domain attribute is set.\n\n### Problem\nNow imagine that a server sends a ``Set-Cookie`` header to the browser which contains a domain attribute that points to a foreign domain (a domain that is not a parent domain of the current host), e.g.:\n```\nHTTP/1.1 200 OK\n[...]\nSet-Cookie: foo=bar; Domain=example.com\n[...]\n```\nIn this example, the current web site is hosted on ``www.canitrust.in`` but the server tries to set a cookie for the foreign domain ``example.com``. This should not be possible as it would allow a rouge website to set cookies on other websites on foreign domains. This could cause functionality disruptions keading to denial-of-service.\n\n### How does the browser react?\nWhen receiving such foreign values for the domain attribute in ``Set-Cookie`` headers, the browser now has two options:\n\n1. Ignore a cookie definition with a foreign domain value. This is the correct and secure implementation.\n2. Accept the cookie anyways and serve it to the foreign domain when it is called the next time.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "1/17/2019",
    "tagNums": [
      2,
      13
    ],
    "path": "foreign-domains-in-cookies",
    "question": "Is the cookie with the foreign domain attribute ignored?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "Yes"
      },
      {
        "ans_id": 0,
        "ans_desc": "No"
      }
    ]
  },
  "9": {
    "testNumber": 9,
    "title": "HttpOnly Handling in JavaScript",
    "description": "What happens if a JS script tries to set a cookie with the httpOnly flag? Does the browser allow this? Does it allow the cookie to be read afterwards?",
    "detailedDescription": "### Introduction\n[Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) are key-value pairs which the server can set in the calling browser, like so:\n``` \nSet-Cookie: foo=bar; HttpOnly\n```\nIn the above example, the server sets the cookie ``foo`` with the value ``bar`` and sets the HttpOnly flag. This flag prevents all access to this cookie from JavaScript functions like the ``Document.cookie`` object or through XHR calls. This is an important function to prevent [Cross-site Scripting (XSS) attacks](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)).\n\nIf a request is made to a server, the browser will automatically send all cookies stored for this [origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin). This is particularly usefull for [session management](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#cookies) where cookies will be used to store session identifiers (session IDs). This behaviour makes such session cookies highly security relevant.\n\n### Problem\nNow imagine the following HTML code:\n```\n<html>\n  <head>[...]</head>\n  <body>\n    <script>\n      document.cookie = \"foo=bar; HttpOnly\";\n    </script>\n    <script>\n      alert(document.cookie);\n    </script>\n  </body>\n</html>\n```\nIn this example, the web site tries to set the cookie ``foo`` with the value ``bar`` and with the ``HttpOnly`` flag set. In the second script block it then tries to read the cookie from the ``Document.cookie`` object.\n\nIf any of these actions would be possible, the browser would have a serious security vulnerability as many web sites rely on the HttpOnly flag to prevent XSS attacks.\n\n### How does the browser react?\nWhen the browser receives JavaScript code that tries to set and read HttpOnly cookies, the following results are possible:\n\n1. The browser does neither allow the setting nor the reading of HttpOnly cookies through JavaScript. This is the correct and safe implementation.\n2. The browser allows both setting and reading HttpOnly cookies. This option would be a serious security vulnerability.\n3. The browser allows setting cookies with the HttpOnly flag, but then does not allow reading them afterwards.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "1/17/2019",
    "tagNums": [
      2,
      6
    ],
    "path": "js-setting-httponly-cookies",
    "question": "Can JavaScript set and read httpOnly cookies?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "No"
      },
      {
        "ans_id": 10,
        "ans_desc": "Set but not read"
      },
      {
        "ans_id": 0,
        "ans_desc": "Yes"
      }
    ]
  },
  "10": {
    "testNumber": 10,
    "title": "Secure Cookie set by HTTP Web Site",
    "description": "What happens if a web site accessed via HTTP tries to set a cookie with the secure flag set? Will the browser simply ignore this cookie or will it actually accept the cookie?",
    "detailedDescription": "### Introduction\n[Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) are key-value pairs which the server can set in the calling browser, like so:\n``` \nSet-Cookie: foo=bar; secure\n```\nIn the above example, the server sets the cookie ``foo`` with the value ``bar`` and sets the secure flag. This flag prevents the browser from sending this cookie to web sites which are not being called via HTTPS and therefore prevents the cookie from being sent unencrypted. This is an important security function to mitigate [man-in-the-middle attacks](https://www.owasp.org/index.php/Man-in-the-middle_attack).\n\nIf a request is made to a server, the browser will automatically send all cookies stored for this [origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin). This is particularly useful for [session management](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#cookies) where cookies will be used to store session identifiers (session IDs). This behaviour makes such session cookies highly security relevant.\n\n### Problem\nSince the secure flag prevents browsers from sending the respective cookie to non-HTTPS sites it should also not be possible for such sites to set secure cookies. Imagine the server sends the following HTTP headers when calling ``http://www.canitrust.in`` (note the ``http://`` part):\n```\nHTTP/1.1 200 OK\n[...]\nSet-Cookie: foo=bar; secure\n[...]\n```\nIn this example, the web site tries to set the cookie ``foo`` with the value ``bar`` and with the ``secure`` flag set. The browser should not accept this cookie as the site was loaded from a non-HTTPS server (``http://www.canitrust.in``).\n\n### How does the browser react?\nWhen the browser receives a ``Set-Cookie`` header with the ``secure`` flag set from a non-HTTPS site, the following results are possible:\n\n1. The browser does not allow setting secure cookies for sites loaded from a non-HTTPS URL. The cookie declaration is ignored. This is the correct and safe implementation.\n2. The browser allows setting secure cookies by non-HTTPS sites. This could lead to security vulnerabilities and should be avoided.\n3. The browser accepts the secure cookie from a non-HTTPS site, but stores it without the ``secure`` flag. This is even more dangerous than the second option.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "06/14/2019",
    "tagNums": [
      2,
      10
    ],
    "path": "http-sites-setting-secure-cookies",
    "question": "Can an HTTP web site set secure cookies?",
    "possibleAnswers": [
      {
        "ans_id": 0,
        "ans_desc": "Yes"
      },
      {
        "ans_id": 1,
        "ans_desc": "No"
      },
      {
        "ans_id": 10,
        "ans_desc": "Cookie was set without the secure flag"
      }
    ]
  },
  "11": {
    "testNumber": 11,
    "title": "Secure cookies set via JavaScript by plain HTTP sources",
    "description": "What happens if JavaScript loaded from an HTTP source tries to set a cookie with the attribute \"secure\"?",
    "detailedDescription": "### Introduction\n[Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) are key-value pairs which the server can set in the calling browser, like so:\n``` \nSet-Cookie: foo=bar; secure\n```\nIn the above example, the server sets the cookie ``foo`` with the value ``bar`` and sets the secure flag. This flag prevents the browser from sending this cookie to web sites which are not being called via HTTPS and therefore prevents the cookie from being sent unencrypted. This is an important security function to prevent [man-in-the-middle attacks](https://www.owasp.org/index.php/Man-in-the-middle_attack).\n\nIf a request is made to a server, the browser will automatically send all cookies stored for this [origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin). This is particularly usefull for [session management](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#cookies) where cookies will be used to store session identifiers (session IDs). This behaviour makes such session cookies highly security relevant.\n\n### Problem\nSince the secure flag prevents browsers from sending the respective cookie to non-HTTPS sites it should also not possible for such sites to set secure cookies. Imagine the following HTML code being sent by a non-HTTPS server, e.g. ``http://www.canitrust.in``:\n```\n<html>\n  <head>[...]</head>\n  <body>\n    <script>\n      document.cookie = \"foo=bar; secure\";\n    </script>\n  </body>\n</html>\n```\nIn this example, the web site tries to set the cookie ``foo`` with the value ``bar`` and with the ``secure`` flag set. The browser should not accept this cookie as the site was loaded from a non-HTTPS server (``http://www.canitrust.in``).\n\n### How does the browser react?\nWhen the browser receives JavaScript code from a non-HTTPS site that tries to set secure cookies, the following results are possible:\n\n1. The browser does not allow the setting secure cookies through JavaScript loaded from a non-HTTPS site. The cookie declaration is ignored. This is the correct and safe implementation.\n2. The browser allows setting secure cookies through JavaScript loaded from a non-HTTPS site. This could lead to security vulnerabilities and should be avoided.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "06/11/2019",
    "tagNums": [
      2,
      10
    ],
    "path": "secure-cookies-set-via-JS-from-HTTP-source",
    "question": "Can plain HTTP sources set secure cookies via JavaScript?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "No, secure cookie is not set."
      },
      {
        "ans_id": 7,
        "ans_desc": "Yes, secure cookie is set."
      },
      {
        "ans_id": 0,
        "ans_desc": "Error in test execution."
      }
    ]
  },
  "13": {
    "testNumber": 13,
    "title": "Contradicting CSP and X-Frame-Options Headers",
    "description": "Which policy is enforced if both a Content Security Policy and the X-Frame-Options header govern the embedding into other pages? According to the specification, the CSP should take precedence.",
    "detailedDescription": "### Introduction\nThe [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) or CSP allows a web application to give detailed instructions to the browser about how to handle its content. This usually happens with an HTTP header like:\n``` \nContent-Security-Policy: frame-ancestors www.canitrust.in\n```\nThe above example tells the browser to not render the content of this site in frames or iframes unless they are loaded from ``www.canitrust.in``.\n\nWith the [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) HTTP header a very similar thing can be achieved:\n```\nX-Frame-Options: deny\n```\nThis header tells the browser to never render the content of this page in a frame or an iframe. If both headers are present the browser should only accept the ``Content-Security-Policy`` header as it [obsoletes](https://www.w3.org/TR/CSP2/#frame-ancestors-and-frame-options) the ``X-Frame-Options`` header.\n\n### Problem\nImagine the following HTML code being sent by the server when requesting ``http://www.canitrust.in``:\n```\n<html>\n  <head>[...]</head>\n  <body>\n    [...]\n    <iframe src=\"http://foo.canitrust.in/index.html\" ></iframe>\n    [...]\n  </body>\n</html\n```\nNow, the browser automatically sends a request to ``http://foo.canitrust.in/index.html`` to load the iframe and receives the following HTTP header:\n```\nHTTP/1.1 200 OK\n[...]\nContent-Security-Policy: frame-ancestors www.canitrust.in\nX-Frame-Options: deny\n[...]\n```\nIn this example, the server sets both the ``Content-Security-Policy`` and the ``X-Frame-Options`` header and their values contradict each other in this case. The ``Content-Security-Policy`` allows the content to be loaded in iframes from within ``www.canitrust.in``, but the ``X-Frame-Options`` disallows the content to be loaded from any origin.\n\n### How does the browser react?\nWhen the browser receives such contradicting HTTP headers when loading the content of an iframe, it has the following two options:\n\n1. Only accept the ``Content-Security-Policy`` header and disregard the ``X-Frame-Options`` header. This is the correct option as it is compliant to the [standard specification](https://www.w3.org/TR/CSP2/#frame-ancestors-and-frame-options).\n2. Only accept the ``X-Frame-Options`` header and disregard the ``Content-Security-Policy`` header.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "05/20/2019",
    "tagNums": [
      3,
      1,
      7
    ],
    "path": "CSP-and-X-Frame-Options-working-together",
    "question": "Which header takes precedence?",
    "possibleAnswers": [
      {
        "ans_id": 2,
        "ans_desc": "CSP"
      },
      {
        "ans_id": 3,
        "ans_desc": "X-Frame-Options"
      }
    ]
  },
  "14": {
    "testNumber": 14,
    "title": "Contradicting CSP Declarations",
    "description": "Which Content Security Policy is enforced if there are two contradicting declarations? The first? The second?",
    "detailedDescription": "### Introduction\nThe [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) or CSP allows a web application to give detailed instructions to the browser about how to handle its content. This usually happens with an HTTP header like:\n``` \nContent-Security-Policy: default-src 'none'; script-src canitrust.in\n```\nThe above example tells the browser to not load any ressources by default (no images, scripts, etc.) and allows scripts to be only loaded from ``canitrust.in``.\n\n### Problem\nNow imagine that a server sends ambiguous or even contradicting CSP headers to the browser, e.g.:\n```\nHTTP/1.1 200 OK\n[...]\nContent-Security-Policy: default-src 'none'; script-src foo.canitrust.in\nContent-Security-Policy: default-src 'self'\n[...]\n```\nAs we are on the host ``www.canitrust.in``, the first CSP header in the above example allows scripts to be loaded only from ``foo.canitrust.in``. Contradicting this, the second CSP header allows scripts to be only loaded from ``self`` which results in ``www.canitrust.in`` in this case.\n\nIf the requested page now tries to load a script from, e.g. ``foo.canitrust.in`` like this\n```\n<html>\n  <head>\n    <script src=\"http://foo.canitrust.in/script.js\" />\n  </head>\n  <body>[...]</body>\n</html>\n```\nThen, if the browser follows the first CSP header the script in this example should be loaded. If the browser accepts the second CSP though, no script should be loaded as the host is not allowed.\n\n### How does the browser react?\nWhen receiving contradicting CSP headers, the browser now basically has two options:\n1. Accept the header which is listed first in the HTTP request and ignore the second.\n2. Accept the second header and ignore the first.\n\nThis testcase tests which browser chooses which of the two options.",
    "date_created": "1/17/2019",
    "tagNums": [
      1,
      7
    ],
    "path": "contradicting-CSP-declarations",
    "question": "Which of the two CSP declarations is enforced?",
    "possibleAnswers": [
      {
        "ans_id": 3,
        "ans_desc": "The first"
      },
      {
        "ans_id": 2,
        "ans_desc": "The second"
      },
      {
        "ans_id": 9,
        "ans_desc": "Error in test execution of the Safari browser, most probably a bug in one of the test components."
      }
    ]
  },
  "15": {
    "testNumber": 15,
    "title": "Frame-src vs. child-src in CSP",
    "description": "When a CSP header contains a frame-src directive, this defines from which sources iframes can be loaded. As fallback, child-src should be used. How does the browsers behave when both frame-src and child-src are defined? Does it follow the frame-src? Or both definitions? Does it block the CSP declaration due to conflicts?",
    "detailedDescription": "### Introduction\nThe [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) or CSP allows a web application to give detailed instructions to the browser about how to handle its content. This usually happens with an HTTP header like:\n``` \nContent-Security-Policy: default-src 'none'; frame-src canitrust.in\n```\nThe above example tells the browser to not load any ressources by default (no images, scripts, etc.) and allows frames and iframes to be only loaded from ``canitrust.in`` through the [frame-src](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-src) directive.\n\nAdditionally, the standard defines the broader [child-src](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/child-src) directive, which is checked to decide whether frames and iframes but also web workers can be loaded from a certain source. For frames and iframes the ``child-src`` directive should only be evaluated if the ``frame-src`` directive is absent.\n\n### Problem\nA server can now send a CSP header which contains both the ``frame-src`` and the ``child-src`` directive, e.g.:\n```\nHTTP/1.1 200 OK\n[...]\nContent-Security-Policy: default-src 'none'; frame-src foo.canitrust.in; child-src bar.canitrust.in\n[...]\n```\nThe ``frame-src`` in the CSP header in the above example allows iframes to be loaded only from ``foo.canitrust.in``. Contradicting this, the ``child-src`` in the same header allows iframes to be sourced from ``bar.canitrust.in``.\n\nNow imagine the requested page tries to load an iframe from ``foo.canitrust.in`` or ``bar.canitrust.in`` like this\n```\n<html>\n  <head>[...]</head>\n  <body>\n      <iframe src=\"http://foo.canitrust.in\"></iframe>\n      <iframe src=\"http://bar.canitrust.in\"></iframe>\n  </body>\n</html>\n```\nIf the browser accepted the ``frame-src`` directive in the CSP header the first iframe in this example should be loaded. If the browser accepts the ``child-src`` directive though, the second iframe should be loaded.\n\n### How does the browser react?\nWhen receiving such contradicting CSP directives, the browser now basically has these options:\n\n1. Accept the ``frame-src`` directive and ignore the ``child-src`` value. This is the correct behaviour as described in the standard.\n2. Accept both the ``frame-src`` and the ``child-src`` and load iframes from both values.\n3. Accept the ``child-src`` directive and ignore the ``frame-src`` value.\n4. Igonre both the ``frame-src`` and the ``child-src`` values and not load iframes from any of these sources.\n\nThis testcase tests which browser chooses which of the these options.",
    "date_created": "08/28/2019",
    "tagNums": [
      1,
      7,
      11,
      12
    ],
    "path": "frame-src-and-child-src-in-CSP",
    "question": "Which of the two CSP declarations is enforced for iframe sources?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "frame-src is enforced, child-src is ignored"
      },
      {
        "ans_id": 6,
        "ans_desc": "Both frame-src and child-src can be used"
      },
      {
        "ans_id": 7,
        "ans_desc": "Only child-src is enforced, frame-src is ignored"
      },
      {
        "ans_id": 9,
        "ans_desc": "Both frame-src and child-src are ignored"
      }
    ]
  },
  "16": {
    "testNumber": 16,
    "title": "Contradicting X-Frame-Options Headers",
    "description": "Which Policy is enforced if the server sends two contradicting X-Frame-Options headers? Always the first or the last header sent? Or does the most restrictive header (deny) have precedence?",
    "detailedDescription": "### Introduction\nWith the [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) HTTP header a server can give instructions to the browser as to whether the content of this site is allowed to be rendered in a frame or an iframe:\n```\nX-Frame-Options: deny\n```\nThis header tells the browser to never render the content of this page in a frame or an iframe. Alternatively, the header can also be sent with the ``sameorigin`` value which allows this content only to be loaded from within pages of the same origin. In legacy browsers another value was allowed:\n```\nX-Frame-Options: allow-from www.canitrust.in\n```\nThis now obsolete directive would allow this content to only be loaded from within ``www.canitrust.in`` and denied from anywhere else.\n\n### Problem\nImagine the following HTML code being sent by the server when requesting ``http://www.canitrust.in``:\n```\n<html>\n  <head>[...]</head>\n  <body>\n    [...]\n    <iframe src=\"http://foo.canitrust.in/index.html\" ></iframe>\n    [...]\n  </body>\n</html\n```\nNow, the browser automatically sends a request to ``http://foo.canitrust.in/index.html`` to load the iframe and receives the following HTTP header:\n```\nHTTP/1.1 200 OK\n[...]\nX-Frame-Options: allow-from www.canitrust.in\nX-Frame-Options: deny\n[...]\n```\nThe two ``X-Frame-Options`` headers in this example contradict each other. The first one allows the content to be loaded in iframes from within ``www.canitrust.in``, but the second one disallows the content to be loaded from any origin.\n\n### How does the browser react?\nWhen the browser receives such contradicting ``X-Frame-Options`` headers when loading the content of an iframe, it has the following options:\n\n1. Only accept the ``X-Frame-Options: deny`` header and disregard the ``allow-from`` value. This is the correct option as the ``allow-from`` directive is obsolete and should be ignored by browsers. Also this option is more secure as it favors the more restrictive header declaration.\n2. Only accept the ``X-Frame-Options: allow-from`` header and disregard the ``deny`` value. This is a rather insecure option as it gives precedence to the more permissive header declaration.\n3. The browser accepts the first ``X-Frame-Options`` header it receives and disregards any following ones, no matter their values.\n4. The browser accepts the last ``X-Frame-Options`` header it receives and disregards any previous ones, no matter their values.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "10/12/2018",
    "tagNums": [
      3,
      7
    ],
    "path": "contradicting-x-frame-options",
    "question": "Which X-Frame-Options header has precedence?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "X-Frame-Options: deny, the most restrictive header"
      },
      {
        "ans_id": 4,
        "ans_desc": "Allow-From headers have precedence"
      },
      {
        "ans_id": 3,
        "ans_desc": "The first header"
      },
      {
        "ans_id": 2,
        "ans_desc": "The last header"
      }
    ]
  },
  "17": {
    "testNumber": 17,
    "title": "Cookie Life Time: max-age vs. expires",
    "description": "The life time of a cookie can be set either via the \"max-age\" or the \"expires\" attribute. What if both methods are used? Which definition is considered by the browser?",
    "detailedDescription": "### Introduction\n[Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) are key-value pairs which the server can set in the calling browser, like so:\n``` \nSet-Cookie: foo=bar; max-age=3600\n```\nIn the above example, the server sets the cookie ``foo`` with the value ``bar`` and sets the ``max-age`` attribute to 3600 seconds (= 1 hour). This attribute tells the browser to delete this cookie after the specified amount of time in seconds. Another way of setting the deletion time of a cookie is with the ``expires`` attribute and the exact date, e.g.\n```\nSet-Cookie: foo=bar; expires=Wed, 21 Oct 2015 07:28:00 GMT\n```\nIf both the ``max-age`` and the ``expires`` are set, the ``max-age`` value should have precedence accoriding to the specification. If none of the two values are set, the cookie becomes a session cookie which will be deleted by the browser when the browser session ends.\n\n### Problem\nSince both the ``max-age`` and the ``expires`` attributes can be used to control the life span of a cookie, browsers have to make a decision if both attributes are set, e.g.:\n```\nHTTP/1.1 200 OK\n[...]\nSet-Cookie: foo=bar; max-age=3600; expires=Wed, 21 Oct 2050 07:28:00 GMT\n[...]\n```\nIn this example, the web site tries to set the cookie ``foo`` with a ``max-age`` value of 1h in the future and additionally with an ``expires`` value a lot further into the future. Therefore, these two attributes contradict each other and the browser has to decide which value to choose.\n\n### How does the browser react?\nWhen the browser receives both a ``max-age`` and an ``expires`` attribute, these two options are possible:\n\n1. The browser chooses the ``max-age`` value and disregards the ``expires`` attribute. This is the correct option according to the specification.\n2. The browser chooses the ``expires`` value and disregards the ``max-age`` attribute.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "01/11/2019",
    "tagNums": [
      2,
      7,
      14,
      15
    ],
    "path": "cookies-with-max-age-and-expires-attributes",
    "question": "What if a cookie is set with max-age and expires attributes?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "The max-age value wins"
      },
      {
        "ans_id": 2,
        "ans_desc": "The expires value wins"
      },
      {
        "ans_id": 0,
        "ans_desc": "Error in test execution"
      }
    ]
  },
  "20": {
    "testNumber": 20,
    "title": "no-store in Cache-Control Declaration",
    "description": "What effect does the header Cache-Control: no-store have? How does the browser behave if a page which sets this header is visited twice? Is the page requested a second time or is the cached version used?",
    "detailedDescription": "### Introduction\nThe [Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) HTTP header is used by the server to indicate to the browser and other caches how to [treat the loaded web site](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching):\n``` \nCache-Control: no-store\n```\nThe value ``no-store`` indicates that the loaded site should not be cached under any circumstances. Therefore, whenever this site is loaded, it must be requested from the server freshly and must never be loaded from a cache like the browser cache.\n\nIn some cases, the caching of web content can become a security problem, e.g. when the web site contains sensitive information like financial data in a banking application, the content should not be stored in the browser or other caches.\n\n### Problem\nTo check how the browser behaves when it receives a ``Cache-Control: no-store``, we load a page that sends HTTP headers similar to this:\n```\nHTTP/1.1 200 OK\n[...]\nCache-Control: no-store\n[...]\n```\nAfter fully loading the page, we request the page a second time. The browser should now send a new request and should not have stored the page loaded at the first time.\n\n### How does the browser react?\nWhen the browser loads a page sending the ``Cache-Control: no-store`` header a second time, these two options are possible:\n\n1. The browser loads the page again from the server. This is the correct behavior.\n2. The browser does not load the page again and displays a cached version. Thois behavior basically ignores the ``Cache-Control`` header.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "1/17/2019",
    "tagNums": [
      5,
      16,
      17
    ],
    "path": "no-store-in-cache-control",
    "question": "How does the browser behave?",
    "possibleAnswers": [
      {
        "ans_id": 2,
        "ans_desc": "The page is requested a second time"
      },
      {
        "ans_id": 3,
        "ans_desc": "The page is not requested a second time"
      }
    ]
  },
  "21": {
    "testNumber": 21,
    "title": "no-cache, no-store, must-revalidate in Cache-Control Declaration",
    "description": "What effect does the header Cache-Control: no-cache, no-store, must-revalidate have? How does the browser behave if a page which sets this header is visited twice? Is the page requested a second time or is the cached version used?",
    "date_created": "11/28/2019",
    "tagNums": [
      5
    ],
    "path": "no-cache-no-store-must-revalidate-in-cache-control",
    "question": "How does the browser behave?",
    "possibleAnswers": [
      {
        "ans_id": 2,
        "ans_desc": "Page not stored at all / browser sends second request without conditional"
      },
      {
        "ans_id": 3,
        "ans_desc": "Browser does not send second request"
      },
      {
        "ans_id": 4,
        "ans_desc": "Browser sends request with conditional (e.g If-None-Match or If-Modified-Since)"
      }
    ]
  },
  "26": {
    "testNumber": 26,
    "title": "must-revalidate in Cache-Control Declarations?",
    "description": "What effect does Cache-Control: must-revalidate have?",
    "date_created": "1/17/2019",
    "tagNums": [
      5
    ],
    "path": "cache-control-must-revalidate",
    "question": "What can be observed?",
    "possibleAnswers": [
      {
        "ans_id": 2,
        "ans_desc": "Page not stored at all / browser sends second request without conditional"
      },
      {
        "ans_id": 3,
        "ans_desc": "Browser does not send second request"
      },
      {
        "ans_id": 4,
        "ans_desc": "Browser sends request with conditional (e.g If-None-Match or If-Modified-Since)"
      }
    ]
  },
  "27": {
    "testNumber": 27,
    "title": "Browser behavior for X-XSS-Protection mode block",
    "description": "How does the browser behave when the server sets the X-XSS-Protection header with the value '1; mode=block' in case of a simple reflected XSS attack? Is the browser able to detect the attack and will the rendering of the entire page be blocked or only the reflected component?",
    "detailedDescription": "### Introduction\nSome browsers offer a feature called XSS Auditor (Chrome, Safari) or [XSS Filter](https://blogs.msdn.microsoft.com/ie/2008/07/02/ie8-security-part-iv-the-xss-filter/) (Internet Explorer, Edge) which is intended to offer the user some basic protection against [reflected Cross-site Scripting](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)) attacks. These protection mechanisms have a default setting in the browser but can also be controlled by the server by setting the following HTTP header:\n``` \nX-XSS-Protection: 1; mode=block\n```\nIn the above example, the server tells the browsers supporting this feature to switch XSS protection on (by setting the value to ``1``) and also to block loading the page in case an XSS attack is detected (with ``mode=block``). Other potential values for this header are:\n``` \nX-XSS-Protection: 0\nX-XSS-Protection: 1\n```\nWith these, value ``0`` instructs the browser to turn off the protection and value ``1`` without ``mode=block`` instructs the browser to filter the identified attack payload instead of blocking the request.\n\nThe protection offered by this feature is rather limited and must therefore not be considered an adequate protection against XSS attacks. Also, browsers which do not support this feature (Firefox, Opera, etc.) will just ignore the header.\n\n### Problem\nEver since the XSS protection features were introduced, researchers have been finding [ways around the protection](https://github.com/EdOverflow/bugbounty-cheatsheet/blob/master/cheatsheets/xss.md) or even [XSS](http://p42.us/ie8xss/Abusing_IE8s_XSS_Filters.pdf) that was only possible due to the XSS Filter. Google and Microsoft have been struggling to keep up up with these vulnerabilities.\n\nMore recently, researchers have found more attacks that are only possible because of the [XSS Filter](https://www.slideshare.net/codeblue_jp/xss-attacks-exploiting-xss-filter-by-masato-kinugawa-code-blue-2015) or [Chrome's XSS Auditor](https://portswigger.net/research/abusing-chromes-xss-auditor-to-steal-tokens). The largest category of those attacks are so-called [Cross-site Leaks](https://portswigger.net/daily-swig/new-xs-leak-techniques-reveal-fresh-ways-to-expose-user-information) and [lots of them](https://github.com/xsleaks/xsleaks/wiki/Links) are only possible due to the XSS Filter or the XSS Auditor.\n\nDue to this series of problems and vulnerabilities first Microsoft decided to turn off the XSS Filter in Edge as described in [this blog post](https://blogs.windows.com/windowsexperience/2018/07/25/announcing-windows-10-insider-preview-build-17723-and-build-18204/#0hOpeoUeI62wJyD1.97) (interestingly, the announcement about new Emojis in the same post gets more than 5 times the screen space). Google first tried to fix some vulnerabilities in Chrome's XSS Auditor by switching the default from blocking (``X-XSS-Protection: 1; mode=block``) to filtering (``X-XSS-Protection: 1``) and back to blocking, but eventually gave in and [retired the XSS Auditor](https://bugs.chromium.org/p/chromium/issues/detail?id=968591) with version 78. After this, Safari and IE will be the last browsers to support this header.\n\nFor further reading on the topic we suggest two excelent articles by the folks from Portswigger:\n* [Google deprecates XSS Auditor for Chrome](https://portswigger.net/daily-swig/google-deprecates-xss-auditor-for-chrome)\n* [XSS protection disappears from Microsoft Edge](https://portswigger.net/daily-swig/xss-protection-disappears-from-microsoft-edge)\n\n### How does the browser react?\nWhen the browser receives an HTTP header as follows:\n``` \nX-XSS-Protection: 1; mode=block\n```\nIt then has a few options on how to react:\n\n  1. The browser complies and turns on XSS protection in blocking mode. This is what Chrome, Safari, Internet Explorer and Edge have been doing for most of the time. As described above, this behaviour is now considered vulnerable and deprecated and should therefore be avoided.\n  2. The browser can ignore the header and fall back to it's default mode. Here each of the three modes could theoretically be a default:\n    * Do not use XSS protection at all. This is what Firefox and Opera have always been doing and what Chrome is doing since version 78. This should be considered the most secure option at the moment.\n    * Use XSS protection but in filter mode. This option does not make much sense.\n    * Use XSS protection in block mode. This option is not distinguishable from option 1 in this case.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "06/11/2019",
    "tagNums": [
      18
    ],
    "path": "x-xss-protection-mode-block",
    "question": "How does the browser behave if the server sets the X-XSS-Protection header to '1; mode=block'?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "The XSS is exploited, no XSS protection is active"
      },
      {
        "ans_id": 6,
        "ans_desc": "The XSS attack is prevented by blocking the entire page"
      },
      {
        "ans_id": 5,
        "ans_desc": "The XSS attack is prevented by filtering and the page rendered"
      }
    ]
  },
  "28": {
    "testNumber": 28,
    "title": "Browser default behavior for X-XSS-Protection",
    "description": "If the server does not set the X-XSS-Protection header, the browser uses a default. Does the browser detect reflected XSS with the default XSS protection and how does it react?",
    "detailedDescription": "### Introduction\nSome browsers offer a feature called XSS Auditor (Chrome, Safari) or [XSS Filter](https://blogs.msdn.microsoft.com/ie/2008/07/02/ie8-security-part-iv-the-xss-filter/) (Internet Explorer, Edge) which is intended to offer the user some basic protection against [reflected Cross-site Scripting](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)) attacks. These protection mechanisms have a default setting in the browser but can also be controlled by the server by setting the following HTTP header:\n``` \nX-XSS-Protection: 1; mode=block\n```\nIn the above example, the server tells the browsers supporting this feature to switch XSS protection on (by setting the value to ``1``) and also to block loading the page in case an XSS attack is detected (with ``mode=block``). Other potential values for this header are:\n``` \nX-XSS-Protection: 0\nX-XSS-Protection: 1\n```\nWith these, value ``0`` instructs the browser to turn off the protection and value ``1`` without ``mode=block`` instructs the browser to filter the identified attack payload instead of blocking the request.\n\nThe protection offered by this feature is rather limited and must therefore not be considered an adequate protection against XSS attacks. Also, browsers which do not support this feature (Firefox, Opera, etc.) will just ignore the header.\n\n### Problem\nEver since the XSS protection features were introduced, researchers have been finding [ways around the protection](https://github.com/EdOverflow/bugbounty-cheatsheet/blob/master/cheatsheets/xss.md) or even [XSS](http://p42.us/ie8xss/Abusing_IE8s_XSS_Filters.pdf) that was only possible due to the XSS Filter. Google and Microsoft have been struggling to keep up up with these vulnerabilities.\n\nMore recently, researchers have found more attacks that are only possible because of the [XSS Filter](https://www.slideshare.net/codeblue_jp/xss-attacks-exploiting-xss-filter-by-masato-kinugawa-code-blue-2015) or [Chrome's XSS Auditor](https://portswigger.net/research/abusing-chromes-xss-auditor-to-steal-tokens). The largest category of those attacks are so-called [Cross-site Leaks](https://portswigger.net/daily-swig/new-xs-leak-techniques-reveal-fresh-ways-to-expose-user-information) and [lots of them](https://github.com/xsleaks/xsleaks/wiki/Links) are only possible due to the XSS Filter or the XSS Auditor.\n\nDue to this series of problems and vulnerabilities first Microsoft decided to turn off the XSS Filter in Edge as described in [this blog post](https://blogs.windows.com/windowsexperience/2018/07/25/announcing-windows-10-insider-preview-build-17723-and-build-18204/#0hOpeoUeI62wJyD1.97) (interestingly, the announcement about new Emojis in the same post gets more than 5 times the screen space). Google first tried to fix some vulnerabilities in Chrome's XSS Auditor by switching the default from blocking (``X-XSS-Protection: 1; mode=block``) to filtering (``X-XSS-Protection: 1``) and back to blocking, but eventually gave in and [retired the XSS Auditor](https://bugs.chromium.org/p/chromium/issues/detail?id=968591) with version 78. After this, Safari and IE will be the last browsers to support this header.\n\nFor further reading on the topic we suggest two excelent articles by the folks from Portswigger:\n* [Google deprecates XSS Auditor for Chrome](https://portswigger.net/daily-swig/google-deprecates-xss-auditor-for-chrome)\n* [XSS protection disappears from Microsoft Edge](https://portswigger.net/daily-swig/xss-protection-disappears-from-microsoft-edge)\n\n### How does the browser react?\nWhen the browser loads a web site and does not receive an ``X-XSS-Protection`` HTTP header, it has to apply a default policy. These are the options:\n\n1. Do not use XSS protection at all, which implies defaulting to ``X-XSS-Protection: 0``. This is what Firefox and Opera have always been doing, what Edge is doing since 2018 and Chrome is doing since version 78. This should be considered the most secure option at the moment.\n2. Use XSS protection but in filter mode, which implies defaulting to ``X-XSS-Protection: 1``. This option was chosen by Chrome for a short period of time trying to fix some vulnerabilities. Safari still uses this option.\n3. Use XSS protection in block mode, which implies defaulting to ``X-XSS-Protection: 1; mode=block``. This option was the chosen default for Chrome and Edge for a long time. Currently, only Internet Explorer still uses it.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "06/11/2019",
    "tagNums": [
      18
    ],
    "path": "x-xss-protection-default-behavior",
    "question": "What can be observed?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "The XSS is exploited, no XSS protection is active"
      },
      {
        "ans_id": 5,
        "ans_desc": "The XSS attack is prevented by filtering and the page rendered"
      },
      {
        "ans_id": 6,
        "ans_desc": "The XSS attack is prevented by blocking the entire page"
      }
    ]
  },
  "29": {
    "testNumber": 29,
    "title": "Browser behavior for X-XSS-Protection with value '1'",
    "description": "How does the browser behave when the server sets the X-XSS-Protection header with the value '1' in case of a simple reflected XSS attack? Is the browser able to detect the attack and will the rendering of the entire page be blocked or only the reflected component?",
    "detailedDescription": "### Introduction\nSome browsers offer a feature called XSS Auditor (Chrome, Safari) or [XSS Filter](https://blogs.msdn.microsoft.com/ie/2008/07/02/ie8-security-part-iv-the-xss-filter/) (Internet Explorer, Edge) which is intended to offer the user some basic protection against [reflected Cross-site Scripting](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)) attacks. These protection mechanisms have a default setting in the browser but can also be controlled by the server by setting the following HTTP header:\n``` \nX-XSS-Protection: 1\n```\nIn the above example, the server tells the browsers supporting this feature to switch XSS protection on (by setting the value to ``1``), try to filter the attack string and then display the sanitized weg site. Other potential values for this header are:\n``` \nX-XSS-Protection: 0\nX-XSS-Protection: 1; mode=block\n```\nWith these, value ``0`` instructs the browser to turn off the protection and value ``1`` with ``mode=block`` instructs the browser to block the rendering of the web site if it detects an attack payload instead of sanitizing it.\n\nThe protection offered by this feature is rather limited and must therefore not be considered an adequate protection against XSS attacks. Also, browsers which do not support this feature (Firefox, Opera, etc.) will just ignore the header.\n\n### Problem\nEver since the XSS protection features were introduced, researchers have been finding [ways around the protection](https://github.com/EdOverflow/bugbounty-cheatsheet/blob/master/cheatsheets/xss.md) or even [XSS](http://p42.us/ie8xss/Abusing_IE8s_XSS_Filters.pdf) that was only possible due to the XSS Filter. Google and Microsoft have been struggling to keep up up with these vulnerabilities.\n\nMore recently, researchers have found more attacks that are only possible because of the [XSS Filter](https://www.slideshare.net/codeblue_jp/xss-attacks-exploiting-xss-filter-by-masato-kinugawa-code-blue-2015) or [Chrome's XSS Auditor](https://portswigger.net/research/abusing-chromes-xss-auditor-to-steal-tokens). The largest category of those attacks are so-called [Cross-site Leaks](https://portswigger.net/daily-swig/new-xs-leak-techniques-reveal-fresh-ways-to-expose-user-information) and [lots of them](https://github.com/xsleaks/xsleaks/wiki/Links) are only possible due to the XSS Filter or the XSS Auditor.\n\nDue to this series of problems and vulnerabilities first Microsoft decided to turn off the XSS Filter in Edge as described in [this blog post](https://blogs.windows.com/windowsexperience/2018/07/25/announcing-windows-10-insider-preview-build-17723-and-build-18204/#0hOpeoUeI62wJyD1.97) (interestingly, the announcement about new Emojis in the same post gets more than 5 times the screen space). Google first tried to fix some vulnerabilities in Chrome's XSS Auditor by switching the default from blocking (``X-XSS-Protection: 1; mode=block``) to filtering (``X-XSS-Protection: 1``) and back to blocking, but eventually gave in and [retired the XSS Auditor](https://bugs.chromium.org/p/chromium/issues/detail?id=968591) with version 78. After this, Safari and IE will be the last browsers to support this header.\n\nFor further reading on the topic we suggest two excelent articles by the folks from Portswigger:\n* [Google deprecates XSS Auditor for Chrome](https://portswigger.net/daily-swig/google-deprecates-xss-auditor-for-chrome)\n* [XSS protection disappears from Microsoft Edge](https://portswigger.net/daily-swig/xss-protection-disappears-from-microsoft-edge)\n\n### How does the browser react?\nWhen the browser receives an HTTP header like ``X-XSS-Protection: 1`` it has a few options on how to react:\n\n  1. The browser complies and turns on XSS protection in filtering mode. This is what Chrome, Safari, Internet Explorer and Edge have been doing for most of the time. As described above, this behaviour is now considered vulnerable and deprecated and should therefore be avoided.\n  2. The browser can ignore the header and fall back to it's default mode. Here each of the three modes could theoretically be a default:\n    * Do not use XSS protection at all. This is what Firefox and Opera have always been doing and what Chrome is doing since version 78. This should be considered the most secure option at the moment.\n    * Use XSS protection but in filter mode. This option is not distinguishable from option 1 in this case.\n    * Use XSS protection in block mode. This option does not make much sense.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "03/12/2019",
    "tagNums": [
      18
    ],
    "path": "x-xss-protection-1",
    "question": "How does the browser behave if the server sets the X-XSS-Protection header to '1'?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "The XSS is exploited, no XSS protection is active"
      },
      {
        "ans_id": 5,
        "ans_desc": "The XSS attack is prevented by filtering and the page rendered"
      },
      {
        "ans_id": 6,
        "ans_desc": "The XSS attack is prevented by blocking the entire page"
      }
    ]
  },
  "30": {
    "testNumber": 30,
    "title": "Browser behavior for X-XSS-Protection with value '0'",
    "description": "How does the browser behave when the server sets the X-XSS-Protection header with the value '0' in case of a simple reflected XSS attack? Is the browser able to detect the attack and will the rendering of the entire page be blocked or only the reflected component?",
    "detailedDescription": "### Introduction\nSome browsers offer a feature called XSS Auditor (Chrome, Safari) or [XSS Filter](https://blogs.msdn.microsoft.com/ie/2008/07/02/ie8-security-part-iv-the-xss-filter/) (Internet Explorer, Edge) which is intended to offer the user some basic protection against [reflected Cross-site Scripting](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)) attacks. These protection mechanisms have a default setting in the browser but can also be controlled by the server by setting the following HTTP header:\n``` \nX-XSS-Protection: 0\n```\nIn the above example, the server tells the browsers supporting this feature to switch XSS protection off (by setting the value to ``0``). Other potential values for this header are:\n``` \nX-XSS-Protection: 1\nX-XSS-Protection: 1; mode=block\n```\nWith these, value ``1`` instructs the browser to turn on the protection by filtering out attack payloads and if ``mode=block`` is additionally set, it instructs the browser to block the rendering of the web site if it detects an attack payload instead of sanitizing it.\n\nThe protection offered by this feature is rather limited and must therefore not be considered an adequate protection against XSS attacks. Also, browsers which do not support this feature (Firefox, Opera, etc.) will just ignore the header.\n\n### Problem\nEver since the XSS protection features were introduced, researchers have been finding [ways around the protection](https://github.com/EdOverflow/bugbounty-cheatsheet/blob/master/cheatsheets/xss.md) or even [XSS](http://p42.us/ie8xss/Abusing_IE8s_XSS_Filters.pdf) that was only possible due to the XSS Filter. Google and Microsoft have been struggling to keep up up with these vulnerabilities.\n\nMore recently, researchers have found more attacks that are only possible because of the [XSS Filter](https://www.slideshare.net/codeblue_jp/xss-attacks-exploiting-xss-filter-by-masato-kinugawa-code-blue-2015) or [Chrome's XSS Auditor](https://portswigger.net/research/abusing-chromes-xss-auditor-to-steal-tokens). The largest category of those attacks are so-called [Cross-site Leaks](https://portswigger.net/daily-swig/new-xs-leak-techniques-reveal-fresh-ways-to-expose-user-information) and [lots of them](https://github.com/xsleaks/xsleaks/wiki/Links) are only possible due to the XSS Filter or the XSS Auditor.\n\nDue to this series of problems and vulnerabilities first Microsoft decided to turn off the XSS Filter in Edge as described in [this blog post](https://blogs.windows.com/windowsexperience/2018/07/25/announcing-windows-10-insider-preview-build-17723-and-build-18204/#0hOpeoUeI62wJyD1.97) (interestingly, the announcement about new Emojis in the same post gets more than 5 times the screen space). Google first tried to fix some vulnerabilities in Chrome's XSS Auditor by switching the default from blocking (``X-XSS-Protection: 1; mode=block``) to filtering (``X-XSS-Protection: 1``) and back to blocking, but eventually gave in and [retired the XSS Auditor](https://bugs.chromium.org/p/chromium/issues/detail?id=968591) with version 78. After this, Safari and IE will be the last browsers to support this header.\n\nFor further reading on the topic we suggest two excelent articles by the folks from Portswigger:\n* [Google deprecates XSS Auditor for Chrome](https://portswigger.net/daily-swig/google-deprecates-xss-auditor-for-chrome)\n* [XSS protection disappears from Microsoft Edge](https://portswigger.net/daily-swig/xss-protection-disappears-from-microsoft-edge)\n\n### How does the browser react?\nWhen the browser receives an HTTP header like ``X-XSS-Protection: 0`` it has a few options on how to react:\n\n  1. The browser complies and turns off XSS protection. As it is not distinguishable from the situation where the browser simply does not support the header and ignores it, this behavior will be the chosen option for Edge, Firefox, Safari, Opera and Chrome since version 78. This should be considered the most secure option at the moment.\n  2. The browser can ignore the header and fall back to it's default mode. Here each of the three modes could theoretically be a default:\n    * Do not use XSS protection at all. This option is not distinguishable from option 1 in this case.\n    * Use XSS protection but in filter mode. As described above, this behaviour is now considered vulnerable and deprecated and should therefore be avoided.\n    * Use XSS protection in block mode. As described above, this behaviour is now considered vulnerable and deprecated and should therefore be avoided.\n\nThis testcase tests which browser chooses which of these options.",
    "date_created": "03/12/2019",
    "tagNums": [
      18
    ],
    "path": "x-xss-protection-0",
    "question": "How does the browser behave if the server sets the X-XSS-Protection header to '0'?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "The XSS is exploited, no XSS protection is active"
      },
      {
        "ans_id": 5,
        "ans_desc": "The XSS attack is prevented by filtering and the page rendered"
      },
      {
        "ans_id": 6,
        "ans_desc": "The XSS attack is prevented by blocking the entire page"
      }
    ]
  },
  "33": {
    "testNumber": 33,
    "title": "Cross-site scripting CSP Bypass using object data",
    "description": "Some versions of Firefox were vulnerable to a trivial CSP Bypass that might enable cross-site attacks. The idea of this testcase is to verify whether or not this technique can be applied to other browsers.",
    "detailedDescription": "### Introduction\nThe following proof-of-concept page is vulnerable to reflected cross-site scripting attacks:\n```\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <h1>CSP Bypass using object data</h1>\n    <p id=\"reflect\"><?=(isset($_GET['payload']) ?  $_GET['payload'] : 'missing GET param payload')?></p>\n</body>\n</html>\n```\nHowever, cross-site scripting attacks are limited by a strict Content Security Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) setting that eliminate the use of inline Javascript:\n```\nHTTP/1.1 200\n[...]\nContent-Security-Policy: default-src 'none'; base-uri 'none'; object-src 'none';\n```\nIn October 2019, a security researcher, Matheus Vrech discovered a technique to bypass the above CSP settings. The author made a working proof of concept that worked for the then-currently Firefox version. Below is the idea of the bypass:\n```\n?payload=<object%20data=\"javascript:alert(1)\"></object>\n```\nWith this testcase, CanITrust team verifies this technique against many other browsers and versions. Furthermore, let's see if in the future, any other browsers would make the same mistake as Mozilla did.",
    "date_created": "04/12/2019",
    "tagNums": [
      1,
      19
    ],
    "path": "csp-object-directive-for-xss-protection",
    "question": "Does the CSP protect from this attack?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "Yes"
      },
      {
        "ans_id": 0,
        "ans_desc": "No"
      }
    ]
  },
  "31": {
    "testNumber": 31,
    "title": "Cookie with a specific path",
    "description": "Do browsers handle the \"path\" directive of cookies correctly?",
    "detailedDescription": "### Introduction\nThe ``Path`` directive of cookies defines the *scope* of the cookies: what URL path the cookies should be sent to.\nThe value of the ``Path`` directive specifies a URL path that must exist in the requested URL in order for the browser to send the cookie. For example, if *Path=/path1* is set, then these paths will match and the cookie will be sent:\n* /path1\n* /path1/subpath\n* /path1/subpath/subsubpath\n\nThe cookie with *Path=/path1* must not be sent to other paths, eg. */path2*.\n### The test\nIn this testcase, we verify the default behavior of browsers to find out whether or not they handle the cookie's ``Path`` directive correctly.",
    "date_created": "05/12/2019",
    "tagNums": [
      2
    ],
    "path": "cookie-path-directive",
    "question": "Does the browser send cookies with a specfic path to diferrent paths?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "No (expected behavior)"
      },
      {
        "ans_id": 0,
        "ans_desc": "Yes (incorrect behavior)"
      },
      {
        "ans_id": 9,
        "ans_desc": "Error during the execution"
      }
    ]
  },
  "34": {
    "testNumber": 34,
    "title": "How browsers treat CSP with an invalid Directive",
    "description": "What would happen if a Content-Security-Policy header contains an invalid directive (eg. due to a policy injection vulnerability)? Does the browser drop the whole CSP setting?",
    "detailedDescription": "### Introduction\nThe [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) or CSP allows a web application to give detailed instructions to the browser about how to handle its content. This usually happens with an HTTP header like:\n``` \nContent-Security-Policy: script-src 'none'; report-uri /security-alert\n```\nThe above example tells the browser to not execute any Javascript code. An in case of a policy violation, the browser should report to the URL specified in the ``report-uri`` directive.\n### Problem\nImagine there is an injection vulnerability that allows attackers to control a part of the Content-Security-Policy header, as shown in the example below.\n```\nHTTP/1.1 200\n[...]\nContent-Security-Policy: script-src 'none'; report-uri /security-alert?source=/?id=<injectable>\n[...]\n```\nIn such cases, attackers might inject an invalid directive, hoping it to break the whole CSP setting. Following payload was used for the test, note the semi-colon and the underscore at the end.\n```\n/?id=1;_\n```\n### How does the browser react?\nWhen the browser receives such CSP header, it has the following two options:\n1. It might just ignores the invalid part and ``still apply the other valid directives``\n2. It treats the whole CSP header as an invalid one and ``does not apply any restriction``.  \n \nThe second option is considered a dangerous behavior as it might allow attackers to bypass strict CSP settings.  \n### Credit\nThe idea of this testcase was first introduced by Gareth Heyes.\n[@garethheyes](https://twitter.com/garethheyes), thank you for the cool research!",
    "date_created": "06/12/2019",
    "tagNums": [
      1,
      19
    ],
    "path": "csp-with-invalid-directives",
    "question": "Does the invalid directive break the whole CSP setting?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "No, the browser just ignores the invalid directive."
      },
      {
        "ans_id": 0,
        "ans_desc": "Yes, the browser drops the whole CSP if it finds an invalid directive."
      },
      {
        "ans_id": 9,
        "ans_desc": "Error during the execution."
      }
    ]
  },
  "32": {
    "testNumber": 32,
    "title": "SameSite cookies",
    "description": "Support for SameSite cookies or do browsers handle the \"SameSite\" directive correctly?",
    "detailedDescription": "### Introduction\nThe ``SameSite`` directive of cookies lets servers require that a cookie shouldn't be sent with cross-site requests, which provides some protection against cross-site request forgery attacks (CSRF). Below is an example:\n```\nSet-Cookie: key=value; SameSite=Strict\n```\nThe ``SameSite`` directive can be set to one of these three values:\n* **None**: The browser will send cookies with both cross-site requests and same-site requests.\n* **Strict**: The browser will not send cookies with cross-site requests.\n* **Lax**: The browser will only send cookies with cross-site requests if the request is classified as a \"top-level navigation\" request, eg. by following a link.\n\nA detailed explanation of the ``SameSite`` directive of cookies can be found here: [https://web.dev/samesite-cookies-explained/](https://web.dev/samesite-cookies-explained/)\n### The test\nThis testcase verifies the support of browsers for the cookie's ``SameSite`` directive. The **Strict** value of the ``SameSite`` directive was used for the test, and the cross-site request was triggered by an embedded iframe.",
    "date_created": "06/11/2019",
    "tagNums": [
      2
    ],
    "path": "browsers-samesite-cookies",
    "question": "Does the browser send cookies with SameSite attribute set to strict on cross-site requests?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "No (expected behavior)."
      },
      {
        "ans_id": 0,
        "ans_desc": "Yes (either \"SameSite\" is not supported or this is an incorrect behavior)."
      },
      {
        "ans_id": 9,
        "ans_desc": "Error during the execution"
      }
    ]
  },
  "66": {
    "testNumber": 66,
    "title": "JavaScript in SVG loaded in IMG tag",
    "description": "SVG images can contain JavaScript code which would be executed in the user's browser if this SVG is loaded in a web site. This becomes dangerous if the JavaScript code can access and change the DOM of the web site loading it. This test case uses a web site which loads an SVG in an IMG tag where the SVG is hosted on the same host. This SVG contains JS code that attempts to change the loading web site.",
    "detailedDescription": "### Introduction\nHTML pages can load [SVG](https://en.wikipedia.org/wiki/Scalable_Vector_Graphics) images and display them. SVG images [can contain JavaScript](https://www.w3.org/TR/SVG11/script.html) code to create animations or make the description of the image easier.\n\nSVGs can be loaded in [different ways](https://vecta.io/blog/best-way-to-embed-svg) in the HTML, e.g. through an ``<img>`` tag:\n``` \n<html>\n  <head>[...]</head>\n  <body>\n    <img src=\"https://static.canitrust.in/cute-cat.svg\"/>\n  </body>\n</html>\n```\n\n### Problem\nIf a web page loads an SVG through an ``<img>`` tag as shown above, the SVG could contain JavaScript code that tries to access the content of the loading page like so:\n```\n<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n\n<svg version=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\">\n  <polygon id=\"triangle\" points=\"0,0 0,50 50,0\" fill=\"#009900\" stroke=\"#004400\"/>\n  <script type=\"text/javascript\">\n    setTimeout(function(){with(document)body.appendChild(createElement('p')).innerHTML = \"Attack\"},500)\n  </script>\n</svg>\n```\nThe above SVG tries to access the [DOM](https://en.wikipedia.org/wiki/Document_Object_Model) and add an element to it. For security reasons the document object of the SVG should be different from that of the surrounding HTML page and therefore not accessible from the JavaScript code inside the SVG. If this would be possible, lots of different attacks from malicious SVGs would be possible against containing websites. This testcase tests whether this is possible.\n\n### How does the browser react?\nWhen loading an SVG in an ``<img>`` tag that contains JavaScript, the following things can happen:\n\n1. The browser does not allow JavaScript code inside an SVG to access the DOM of the surrounding page and therefore does not allow changeing web page content. This is the secure and correct option.\n2. The browser does allow JavaScript inside an SVG image to access and manipulate the DOM of the surrounding page. This would be a vulnerable implementation.\n\nThis testcase tests which browser chooses which of the these options.",
    "date_created": "06/26/2019",
    "tagNums": [
      9
    ],
    "path": "JS-in-SVG-loaded-by-img",
    "question": "Can the JavaScript code inside the SVG change the web site's content?",
    "possibleAnswers": [
      {
        "ans_id": 1,
        "ans_desc": "No"
      },
      {
        "ans_id": 0,
        "ans_desc": "Yes"
      },
      {
        "ans_id": 9,
        "ans_desc": "Error during the execution"
      }
    ]
  },
  "67": {
    "testNumber": 67,
    "title": "JavaScript in SVG loaded in OBJECT tag",
    "description": "SVG images can contain JavaScript code which would be executed in the user's browser if this SVG is loaded in a web site. This becomes dangerous if the JavaScript code can access and change the DOM of the web site loading it. This test case uses a web site which loads an SVG in an OBJECT tag where the SVG is hosted on the same host. This SVG contains JS code that attempts to change the loading web site.",
    "detailedDescription": "### Introduction\nHTML pages can load [SVG](https://en.wikipedia.org/wiki/Scalable_Vector_Graphics) images and display them. SVG images [can contain JavaScript](https://www.w3.org/TR/SVG11/script.html) code to create animations or make the description of the image easier.\n\nSVGs can be loaded in [different ways](https://vecta.io/blog/best-way-to-embed-svg) in the HTML, e.g. through an ``<object>`` tag:\n``` \n<html>\n  <head>[...]</head>\n  <body>\n    <object type=\"image/svg+xml\" data=\"https://static.canitrust.in/cute-cat.svg\"></object>\n  </body>\n</html>\n```\n\n### Problem\nIf a web page loads an SVG through an ``<object>`` tag as shown above, the SVG could contain JavaScript code that tries to access the content of the loading page like so:\n```\n<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n\n<svg version=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\">\n  <polygon id=\"triangle\" points=\"0,0 0,50 50,0\" fill=\"#009900\" stroke=\"#004400\"/>\n  <script type=\"text/javascript\">\n    setTimeout(function(){window.parent.document.body.getElementsByTagName('p')[0].innerHTML = \"Attack\"},500)\n  </script>\n</svg>\n```\nThe above SVG tries to access the [DOM](https://en.wikipedia.org/wiki/Document_Object_Model) and add an element to it. For security reasons the document object of the SVG should be different from that of the surrounding HTML page and therefore not accessible from the JavaScript code inside the SVG. If this would be possible, lots of different attacks from malicious SVGs would be possible against containing websites. This testcase tests whether this is possible.\n\n### How does the browser react?\nWhen loading an SVG in an ``<object>`` tag that contains JavaScript, the following things can happen:\n\n1. The browser does not allow JavaScript code inside an SVG to access the DOM of the surrounding page and therefore does not allow changeing web page content. This is the secure and correct option.\n2. The browser does allow JavaScript inside an SVG image to access and manipulate the DOM of the surrounding page. This would be a vulnerable implementation.\n\nThis testcase tests which browser chooses which of the these options.",
    "date_created": "12/05/2019",
    "tagNums": [
      9
    ],
    "path": "JS-in-SVG-loaded-by-object",
    "question": "Can the JavaScript code inside the SVG change the web site's content?",
    "possibleAnswers": [
      {
        "ans_id": 0,
        "ans_desc": "No"
      },
      {
        "ans_id": 1,
        "ans_desc": "Yes"
      },
      {
        "ans_id": 9,
        "ans_desc": "Error during the execution"
      }
    ]
  },
  "68": {
    "testNumber": 68,
    "title": "JavaScript in SVG loaded in EMBED tag",
    "description": "SVG images can contain JavaScript code which would be executed in the user's browser if this SVG is loaded in a web site. This becomes dangerous if the JavaScript code can access and change the DOM of the web site loading it. This test case uses a web site which loads an SVG in an EMBED tag where the SVG is hosted on the same host. This SVG contains JS code that attempts to change the loading web site.",
    "detailedDescription": "### Introduction\nHTML pages can load [SVG](https://en.wikipedia.org/wiki/Scalable_Vector_Graphics) images and display them. SVG images [can contain JavaScript](https://www.w3.org/TR/SVG11/script.html) code to create animations or make the description of the image easier.\n\nSVGs can be loaded in [different ways](https://vecta.io/blog/best-way-to-embed-svg) in the HTML, e.g. through an ``<embed>`` tag:\n``` \n<html>\n  <head>[...]</head>\n  <body>\n    <embed type=\"image/svg+xml\" src=\"https://static.canitrust.in/cute-cat.svg\"/>\n  </body>\n</html>\n```\n\n### Problem\nIf a web page loads an SVG through an ``<embed>`` tag as shown above, the SVG could contain JavaScript code that tries to access the content of the loading page like so:\n```\n<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n\n<svg version=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\">\n  <polygon id=\"triangle\" points=\"0,0 0,50 50,0\" fill=\"#009900\" stroke=\"#004400\"/>\n  <script type=\"text/javascript\">\n    setTimeout(function(){window.parent.document.body.getElementsByTagName('p')[0].innerHTML = \"Attack\"},500)\n  </script>\n</svg>\n```\nThe above SVG tries to access the [DOM](https://en.wikipedia.org/wiki/Document_Object_Model) and add an element to it. This testcase tests whether this is possible.\n\n### How does the browser react?\nWhen loading a **same origin** SVG in an ``<embed>`` tag that contains JavaScript, the following things can happen:\n\n1. The browser does not allow JavaScript code inside an SVG to access the DOM of the surrounding page and therefore does not allow changeing web page content.\n2. The browser does allow JavaScript inside an SVG image to access and manipulate the DOM of the surrounding page.\n\nThis testcase tests which browser chooses which of the these options.",
    "date_created": "12/05/2019",
    "tagNums": [
      9
    ],
    "path": "JS-in-SVG-loaded-by-embed",
    "question": "Can the JavaScript code inside the SVG change the web site's content?",
    "possibleAnswers": [
      {
        "ans_id": 0,
        "ans_desc": "No"
      },
      {
        "ans_id": 1,
        "ans_desc": "Yes"
      },
      {
        "ans_id": 9,
        "ans_desc": "Error during the execution"
      }
    ]
  },
  "72": {
    "testNumber": 72,
    "title": "Contradicting HSTS Headers",
    "description": "Which Policy is enforced, if the server sends two contradicting Strict-Transport-Security (HSTS) headers? Alway the first or the last header set by the server? Or is the result dependant on the max-age value of the header?",
    "detailedDescription": "### Introduction\nThe [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) HTTP header, often called HSTS, instructs the browser how SSL/TLS should be handled for this web site, e.g.:\n``` \nStrict-Transport-Security: max-age=31536000\n```\nThe above example tells the browser a number of things:\n1. This web site must only be called via HTTPS, never via HTTP.\n2. If an HTTP connection for this web site is requested, the browser automatically upgrades to HTTPS.\n3. This setting will be stored in the browaser for 31536000 seconds or 1 year.\n\nThis header is an important defence against man-in-the-middle attacks where an attacker tries to intercept connections before the SSL encryption is active and change HTTPS links to HTTP (so-called [SSL stripping](https://moxie.org/software/sslstrip/) attacks).\n\n### Problem\nImagine the server sends two separate ``Strict-Transport-Security`` headers with contradicting ``max-age`` values like this:\n```\nHTTP/1.1 200 OK\n[...]\nStrict-Transport-Security: max-age=31536000\nStrict-Transport-Security: max-age=123\n[...]\n```\nIn this example, the two ``max-age`` values greatly differ: The first value tells the browser to keep up the HSTS protection for 1 year whereas the second value only stores the HSTS setting for a bit over 2 minutes. If the browser accepted the second header, the protection would be virtually non-existant.\n\n### How does the browser react?\nWhen the browser receives such contradicting HSTS headers when loading a web site, it has the following two options:\n\n1. Only accept the last ``Strict-Transport-Security`` header received from the server and ignore any previous headers.\n2. Only accept the first ``Strict-Transport-Security`` header received from the server and ignore any headers afterwards.\n3. Only accept the ``Strict-Transport-Security`` header with the longest ``max-age`` value and ignore the rest.\n4. Only accept the ``Strict-Transport-Security`` header with the shortest ``max-age`` value and ignore the rest.\n\nAll of these options make sense to a certain degree and none of them can be considered the correct solution in our opinion. This testcase tests which browser chooses which of these options.",
    "date_created": "07/03/2019",
    "tagNums": [
      4,
      7
    ],
    "path": "contradicting-HSTS-headers",
    "question": "Which HSTS header is used?",
    "possibleAnswers": [
      {
        "ans_id": 3,
        "ans_desc": "Always the last header"
      },
      {
        "ans_id": 4,
        "ans_desc": "Always the first header"
      },
      {
        "ans_id": 2,
        "ans_desc": "Always the header with the longest max-age value"
      },
      {
        "ans_id": 5,
        "ans_desc": "Always the header with the shortest max-age value"
      },
      {
        "ans_id": 9,
        "ans_desc": "Error in test execution"
      }
    ]
  }
}